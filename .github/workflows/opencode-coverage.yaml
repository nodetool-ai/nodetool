name: OpenCode Coverage Improvement

on:
  schedule:
    - cron: "0 9 * * 6" # Weekly on Saturdays at 9 AM UTC
  workflow_dispatch: # Allow manual trigger

jobs:
  opencode-coverage:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Install web dependencies
        run: |
          cd web
          npm ci

      - name: Install electron dependencies
        run: |
          cd electron
          npm ci

      - name: Run tests with coverage
        run: |
          cd web
          npm run test:coverage -- --json --outputFile=coverage-summary.json || true
          cat coverage-summary.json

      - name: Run OpenCode
        uses: anomalyco/opencode/github@latest
        env:
          MINIMAX_API_KEY: ${{ secrets.MINIMAX_API_KEY }}
        with:
          model: minimax/MiniMax-M2.1
          prompt: |
            # NodeTool Test Coverage Improvement

            You are an autonomous testing agent improving test coverage for NodeTool.

            ## Your Mission

            **Increase test coverage** by adding tests for untested or undertested code. Focus on critical functionality and high-value tests.

            ## Project Context

            **NodeTool** is a React/TypeScript visual AI workflow builder.
            - **Tech Stack**: React 18.2, TypeScript 5.7, Zustand, ReactFlow, MUI v7
            - **Testing**: Jest 29 + React Testing Library 16 + Playwright (E2E)
            - **Coverage goal**: 70%+ for critical paths

            ## Step 0: Check for Duplicate Work (CRITICAL!)

            **BEFORE starting any work**:
            1. **Run `git branch -a`** to see all existing branches
            2. **Check for branches** with test additions
            3. **Avoid creating duplicate branches**

            ## Step 1: Check Memory (REQUIRED)

            **Read these files FIRST**:
            1. **`.github/opencode-memory/features.md`** - Understand what needs testing
            2. `.github/opencode-memory/build-test-lint.md` - Testing requirements
            3. `.github/opencode-memory/common-issues.md` - Known testing issues
            4. `.github/opencode-memory/insights.md` - Testing patterns

            ## Step 2: Analyze Coverage

            ### Check Current Coverage

            Coverage data was generated in previous step: `web/coverage-summary.json`

            **Analyze coverage**:
            ```bash
            # View coverage report
            cd web
            cat coverage/coverage-summary.json

            # Find untested files
            find src -name "*.ts" -o -name "*.tsx" | while read f; do
              test_file="${f%.tsx}.test.tsx"
              test_file="${test_file%.ts}.test.ts"
              if [ ! -f "$test_file" ]; then
                echo "No test: $f"
              fi
            done
            ```

            ### Priority for Testing

            **High Priority** (must test):
            1. **Stores**: State management logic (Zustand stores)
            2. **Hooks**: Custom React hooks with logic
            3. **Utils**: Utility functions and helpers
            4. **API clients**: Data fetching and API calls
            5. **Critical components**: Complex UI components

            **Medium Priority** (should test):
            1. **Component logic**: Components with business logic
            2. **Context providers**: React context implementations
            3. **Form handlers**: Form validation and submission
            4. **Error handling**: Error boundary and recovery

            **Low Priority** (nice to test):
            1. **Simple components**: Presentational components
            2. **Types**: TypeScript type definitions
            3. **Constants**: Configuration constants
            4. **Styles**: Styled components

            ### Identify Gaps

            **Find untested critical code**:
            ```bash
            # Stores without tests
            find web/src/stores -name "*.ts" ! -name "*.test.ts" -type f

            # Hooks without tests
            find web/src/hooks -name "*.ts" ! -name "*.test.ts" -type f

            # Utils without tests
            find web/src/utils -name "*.ts" ! -name "*.test.ts" -type f

            # Complex components without tests
            find web/src/components -name "*.tsx" ! -name "*.test.tsx" -type f | \
              xargs wc -l | sort -rn | head -20
            ```

            ## Step 3: Write Quality Tests

            ### Testing Patterns

            **React Testing Library approach**:
            - Test behavior, not implementation
            - Use accessible queries (getByRole, getByLabelText)
            - Use userEvent for interactions
            - Wait for async updates

            **Jest patterns**:
            - One test file per source file
            - Descriptive test names
            - AAA pattern: Arrange, Act, Assert
            - Mock external dependencies

            ### Store Testing

            **Zustand store tests**:
            ```typescript
            // MyStore.test.ts
            import { renderHook, act } from '@testing-library/react';
            import { useMyStore } from './MyStore';

            describe('MyStore', () => {
              beforeEach(() => {
                // Reset store before each test
                useMyStore.setState(useMyStore.getInitialState());
              });

              it('initializes with correct default state', () => {
                const { result } = renderHook(() => useMyStore());
                expect(result.current.items).toEqual([]);
              });

              it('adds item to store', () => {
                const { result } = renderHook(() => useMyStore());
                
                act(() => {
                  result.current.addItem({ id: '1', name: 'Test' });
                });

                expect(result.current.items).toHaveLength(1);
                expect(result.current.items[0].name).toBe('Test');
              });

              it('removes item from store', () => {
                const { result } = renderHook(() => useMyStore());
                
                act(() => {
                  result.current.addItem({ id: '1', name: 'Test' });
                  result.current.removeItem('1');
                });

                expect(result.current.items).toHaveLength(0);
              });
            });
            ```

            ### Hook Testing

            **Custom hook tests**:
            ```typescript
            // useMyHook.test.ts
            import { renderHook, waitFor } from '@testing-library/react';
            import { useMyHook } from './useMyHook';

            describe('useMyHook', () => {
              it('returns initial data', () => {
                const { result } = renderHook(() => useMyHook('test-id'));
                
                expect(result.current.data).toBeUndefined();
                expect(result.current.loading).toBe(true);
              });

              it('fetches data successfully', async () => {
                const { result } = renderHook(() => useMyHook('test-id'));
                
                await waitFor(() => {
                  expect(result.current.loading).toBe(false);
                });

                expect(result.current.data).toBeDefined();
                expect(result.current.error).toBeNull();
              });

              it('handles fetch error', async () => {
                // Mock API to return error
                jest.spyOn(global, 'fetch').mockRejectedValueOnce(
                  new Error('API Error')
                );

                const { result } = renderHook(() => useMyHook('test-id'));
                
                await waitFor(() => {
                  expect(result.current.loading).toBe(false);
                });

                expect(result.current.error).toBeDefined();
              });
            });
            ```

            ### Component Testing

            **React component tests**:
            ```typescript
            // MyComponent.test.tsx
            import { render, screen, waitFor } from '@testing-library/react';
            import userEvent from '@testing-library/user-event';
            import { MyComponent } from './MyComponent';

            describe('MyComponent', () => {
              it('renders component', () => {
                render(<MyComponent title="Test" />);
                expect(screen.getByText('Test')).toBeInTheDocument();
              });

              it('handles user interaction', async () => {
                const user = userEvent.setup();
                const onSave = jest.fn();
                
                render(<MyComponent onSave={onSave} />);
                
                await user.click(screen.getByRole('button', { name: /save/i }));
                
                expect(onSave).toHaveBeenCalledTimes(1);
              });

              it('displays error state', () => {
                render(<MyComponent error="Something went wrong" />);
                expect(screen.getByText('Something went wrong')).toBeInTheDocument();
              });

              it('displays loading state', () => {
                render(<MyComponent loading />);
                expect(screen.getByRole('progressbar')).toBeInTheDocument();
              });
            });
            ```

            ### Utility Testing

            **Utility function tests**:
            ```typescript
            // formatDate.test.ts
            import { formatDate } from './formatDate';

            describe('formatDate', () => {
              it('formats date correctly', () => {
                const date = new Date('2026-01-12T12:00:00Z');
                expect(formatDate(date)).toBe('Jan 12, 2026');
              });

              it('handles invalid date', () => {
                expect(formatDate(null)).toBe('Invalid date');
              });

              it('uses custom format', () => {
                const date = new Date('2026-01-12T12:00:00Z');
                expect(formatDate(date, 'YYYY-MM-DD')).toBe('2026-01-12');
              });
            });
            ```

            ### Async Testing

            **Testing async operations**:
            ```typescript
            // Async component test
            it('fetches and displays data', async () => {
              render(<DataComponent id="123" />);
              
              // Wait for loading to finish
              await waitFor(() => {
                expect(screen.queryByRole('progressbar')).not.toBeInTheDocument();
              });
              
              // Check data is displayed
              expect(screen.getByText('Data loaded')).toBeInTheDocument();
            });

            // Async hook test
            it('updates data on refresh', async () => {
              const { result } = renderHook(() => useData('123'));
              
              await waitFor(() => {
                expect(result.current.loading).toBe(false);
              });
              
              act(() => {
                result.current.refresh();
              });
              
              expect(result.current.loading).toBe(true);
            });
            ```

            ### Mocking

            **Mock API calls**:
            ```typescript
            // Mock fetch
            global.fetch = jest.fn(() =>
              Promise.resolve({
                ok: true,
                json: () => Promise.resolve({ data: 'test' }),
              })
            ) as jest.Mock;

            // Or use MSW (Mock Service Worker)
            import { rest } from 'msw';
            import { setupServer } from 'msw/node';

            const server = setupServer(
              rest.get('/api/data', (req, res, ctx) => {
                return res(ctx.json({ data: 'test' }));
              })
            );

            beforeAll(() => server.listen());
            afterEach(() => server.resetHandlers());
            afterAll(() => server.close());
            ```

            **Mock Zustand stores**:
            ```typescript
            import { useNodeStore } from '../stores/NodeStore';

            jest.mock('../stores/NodeStore');

            beforeEach(() => {
              (useNodeStore as jest.Mock).mockReturnValue({
                nodes: [],
                addNode: jest.fn(),
              });
            });
            ```

            ## Step 4: Test Quality Checklist

            Good tests should:
            - [ ] Test behavior, not implementation
            - [ ] Have descriptive test names
            - [ ] Be independent (no test order dependency)
            - [ ] Test edge cases and error conditions
            - [ ] Use appropriate assertions
            - [ ] Clean up resources (timers, listeners, etc.)
            - [ ] Run fast (mock slow operations)
            - [ ] Be maintainable (clear and simple)

            ## Step 5: Run and Verify Tests

            **After adding tests**:

            ```bash
            # Run new tests
            cd web
            npm test -- path/to/new.test.ts

            # Run all tests
            npm test

            # Check coverage
            npm run test:coverage

            # Verify quality checks pass
            npm run typecheck
            npm run lint
            ```

            ## Step 6: Update Memory

            **After improving coverage**, update memory files:

            1. **`.github/opencode-memory/build-test-lint.md`**:
               - Document testing patterns used
               - Update coverage status

            2. **`.github/opencode-memory/insights.md`**:
               - Share effective testing patterns
               - Document mock strategies

            3. **`.github/opencode-memory/common-issues.md`**:
               - Document testing challenges solved

            **After updating memory files, COMPACT THEM**:
            ```bash
            python scripts/compact-memory.py
            ```

            **Format**:
            ```markdown
            ### Test Coverage Improvement (2026-01-12)

            **Coverage Before**: X%
            **Coverage After**: Y%
            **Tests Added**: Number and types
            **Areas Covered**: List of modules/features tested
            **Patterns Used**: Testing patterns employed
            **Files**: List of test files created
            ```

            ## Common Testing Challenges

            ### Challenge 1: Testing ReactFlow
            ```typescript
            // Mock ReactFlow for component tests
            jest.mock('@xyflow/react', () => ({
              ReactFlow: ({ children }: any) => <div>{children}</div>,
              useReactFlow: () => ({
                fitView: jest.fn(),
                setNodes: jest.fn(),
              }),
            }));
            ```

            ### Challenge 2: Testing Zustand with Temporal
            ```typescript
            // Reset temporal middleware between tests
            import { useNodeStore } from './NodeStore';

            afterEach(() => {
              const state = useNodeStore.getState();
              state.temporal.clear();
              useNodeStore.setState(useNodeStore.getInitialState());
            });
            ```

            ### Challenge 3: Testing WebSocket
            ```typescript
            // Mock WebSocket
            class MockWebSocket {
              onopen: (() => void) | null = null;
              onmessage: ((event: any) => void) | null = null;
              onerror: ((error: any) => void) | null = null;

              send(data: string) {
                // Mock send
              }

              close() {
                // Mock close
              }
            }

            global.WebSocket = MockWebSocket as any;
            ```

            ## Best Practices

            1. **Start with critical code**: Stores, hooks, utils first
            2. **Write small focused tests**: One thing per test
            3. **Test happy path first**: Then edge cases
            4. **Mock external dependencies**: Keep tests fast
            5. **Use descriptive names**: Test names should explain what they test
            6. **Follow existing patterns**: Look at existing tests
            7. **Don't test implementation**: Test behavior users see

            ## What NOT to Test

            ❌ **Don't test**:
            - Third-party library code
            - Simple getters/setters
            - TypeScript types (TypeScript does this)
            - Trivial code
            - Generated code
            - Implementation details

            ✅ **DO test**:
            - Business logic
            - User interactions
            - Edge cases and errors
            - State management
            - Data transformations
            - Critical paths

            ## If Coverage Is Good

            If coverage is already high:
            1. Document good coverage in memory
            2. Optionally add tests for edge cases
            3. Optionally improve existing test quality
            4. Don't add unnecessary tests

            ## Remember

            Good tests are documentation. They show how code should work. They catch regressions. They enable refactoring. Focus on high-value tests for critical functionality.

            Now, improve NodeTool's test coverage! ✅
