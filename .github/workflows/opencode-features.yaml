name: Hourly OpenCode Features

on:
  schedule:
    - cron: "0 */6 * * *" # Every 6 hours

jobs:
  opencode:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: write
      pull-requests: write
      issues: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for all branches to enable merging and conflict resolution

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: web/package-lock.json

      - name: Install web dependencies
        run: |
          cd web
          npm ci

      - name: Install electron dependencies
        run: |
          cd electron
          npm ci

      - name: Run OpenCode
        uses: anomalyco/opencode/github@latest
        env:
          ZAI_API_KEY: ${{ secrets.ZAI_API_KEY }}
        with:
          model: zai-coding-plan/glm-4.7
          prompt: |
            # NodeTool Feature Development (Scheduled Workflow)

            You are an autonomous agent adding valuable features to NodeTool, a visual AI workflow builder.

            ## Your Mission

            **Develop ONE thoughtful, exciting feature** that enhances NodeTool. Can be small and polished or bold and innovative.

            ## Project Understanding

            **What is NodeTool?**
            - Visual AI workflow builder (drag-and-drop nodes, no coding)
            - React 18.2 + TypeScript 5.7 + Zustand + ReactFlow + MUI v7
            - Frontend-only repo: `/web` (React app), `/electron` (desktop), `/mobile` (React Native)
            - Backend is separate Python repo

            **Core Technologies**:
            - State: Zustand stores with temporal middleware (undo/redo)
            - Editor: ReactFlow for node-based visual editing
            - UI: Material-UI v7 with emotion styling
            - Data: TanStack Query for API state
            - Testing: Jest + React Testing Library + Playwright

            ## Step 1: Check for Duplicate Work (CRITICAL!)

            **BEFORE starting any work**:
            1. **Run `git branch -a`** to see all existing branches
            2. **Check for branches** with similar names or purposes
            3. **Avoid creating duplicate branches** for the same feature
            4. If a branch exists for similar work:
               - Review what's already done
               - Consider if you should continue that work
               - Don't duplicate efforts
            
            ## Step 2: Learn from Memory (REQUIRED)

            **Read these files and folders FIRST** to avoid redundant work:
            1. **`.github/opencode-memory/features.md`** - Complete feature list (MUST READ!)
            2. **`.github/opencode-memory/issues/`** - List folders to see known issues by topic
               - Check `issues/typescript/`, `issues/testing/`, etc. as relevant
            3. **`.github/opencode-memory/insights/`** - List folders to learn best practices
               - Check `insights/architecture/`, `insights/performance/`, etc.
            4. `.github/opencode-memory/project-context.md` - Recent changes

            **CRITICAL**: Check `features.md` to ensure your feature doesn't already exist!

            ## Step 3: Explore and Plan

            1. **Check for duplicates**: Search `features.md` for similar functionality
            2. **Read documentation**: `/AGENTS.md`, `/web/README.md`, `/.github/copilot-instructions.md`
            3. **Understand the codebase**: Explore relevant directories
            4. **Think creatively**: What would make NodeTool better?
            5. **Validate feasibility**: Can it be done with frontend-only changes?
            6. **Confirm uniqueness**: Ensure feature is not redundant with existing features

            **Feature Ideas** (or come up with your own):
            - Enhanced keyboard shortcuts or accessibility
            - Improved node search/filtering
            - Better error visualization in workflows
            - Node templates or snippets
            - Enhanced asset management UI
            - Performance optimizations (virtualization, memoization)
            - Better mobile/responsive experience
            - Visual improvements to node editor
            - Workflow documentation/comments feature
            - Enhanced drag-and-drop capabilities

            ## Step 3: Implement with Quality

            ### Code Quality Standards (Non-Negotiable)

            **TypeScript**:
            - Strict mode, explicit types, no `any`
            - Use `===` not `==`
            - Use `Array.isArray()` for array checks
            - Throw `Error` objects, not strings

            **React Patterns**:
            ```typescript
            // âœ… Functional components with typed props
            interface Props {
              nodeId: string;
              onSave?: (data: Data) => void;
            }

            export const MyComponent: React.FC<Props> = ({ nodeId, onSave }) => {
              // Use selective Zustand subscriptions
              const node = useNodeStore(state => state.nodes[nodeId]);

              // Memoize callbacks
              const handleSave = useCallback(() => {
                onSave?.(data);
              }, [onSave, data]);

              return <Box sx={{ p: 2 }}>{/* ... */}</Box>;
            };
            ```

            **MUI Styling**:
            ```typescript
            // Always use theme values
            <Box sx={{
              p: 2,                    // theme.spacing(2)
              bgcolor: 'primary.main', // theme.palette.primary.main
              mb: 1                    // theme.spacing(1)
            }}>
            ```

            **Testing**:
            - Add tests for new functionality
            - Follow existing test patterns
            - Test behavior, not implementation
            - Use accessible queries (`getByRole`, `getByLabelText`)

            ### Mandatory Quality Checks

            **MUST pass before opening PR:**
            ```bash
            make typecheck  # Exit code 0 required
            make lint       # Exit code 0 required
            make test       # Exit code 0 required
            ```

            Run `make lint-fix` to auto-fix many issues.

            ## Step 4: Document and Update Memory

            **After completing your feature**, update memory:

            1. **`.github/opencode-memory/features.md`** - Add ONE line describing your feature:
               ```markdown
               - **Feature Name**: Brief description (max 10 words)
               ```
            
            2. **`.github/opencode-memory/project-context.md`** - Add ONE line under "Recent Changes" (MAX 5 entries, delete oldest):
               ```markdown
               - **Feature Name (YYYY-MM-DD)**: One sentence. Files: main-file.tsx, other-file.ts
               ```
            
            3. **`.github/opencode-memory/issues/<topic>/`** - ONLY if you solved a tricky problem:
               - Create a new file with kebab-case name (e.g., `my-issue-fix.md`)
               - Format:
               ```markdown
               # Issue Title

               **Problem**: One sentence

               **Solution**: One sentence or brief code snippet

               **Date**: YYYY-MM-DD
               ```
            
            4. **`.github/opencode-memory/insights/<topic>/`** - ONLY for significant learnings:
               - Create a new file with kebab-case name (e.g., `my-insight.md`)
               - Format:
               ```markdown
               # Insight Title

               **Insight**: What was learned

               **Example**: Code example (if applicable)

               **Date**: YYYY-MM-DD
               ```

            **Keep it minimal** - Only write truly important information that will help future agents avoid redundant work.

            ## Best Practices for Autonomous Work

            1. **Start small**: Better to ship a small, polished feature than fail at a large one
            2. **Follow patterns**: Look at existing code, maintain consistency
            3. **Test incrementally**: Run checks early and often
            4. **Be surgical**: Minimal, focused changes
            5. **Learn from history**: Memory files contain valuable lessons
            6. **Document insights**: Help future runs avoid your mistakes

            ## Reference Documentation

            - **Main docs**: `/AGENTS.md` - Project architecture and commands
            - **Coding patterns**: `/.github/copilot-instructions.md` - Detailed examples
            - **Web setup**: `/web/README.md` - Development setup
            - **Testing**: `/web/TESTING.md` - Testing guide
            - **Component patterns**: `/web/src/components/AGENTS.md`
            - **Store patterns**: `/web/src/stores/AGENTS.md`

            ## Key Principles

            - **Quality over quantity**: One good feature > multiple broken ones
            - **Respect conventions**: Follow established patterns
            - **Test thoroughly**: Validate your work
            - **Learn and share**: Update memory for future runs
            - **Be bold but careful**: Innovate within the constraints

            ## Remember

            You're working autonomously. There's no human to ask for clarification. Make smart, conservative decisions. When in doubt, follow existing patterns. Check memory files first!

            Now, create something valuable for NodeTool! ðŸš€
